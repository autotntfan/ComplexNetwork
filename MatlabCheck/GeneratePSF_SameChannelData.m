function GeneratePSF_SameChannelData(Nmatlab, Npsfset)
% Generate simulated RF/BB point spread function and its associated RF/BB speckle
% Generated file: 
% Data_i_delay_k, the i-th set and level-k phase aberration.
% For each set, PSFs are generated from the same channel data but suffers
% different levels of phase aberration. Speckles are generated by different
% scatterer distribution.
% Nmatlab: Generate PSF set using the i-th matlab programming winodow or
% pool.
% Npsfset: How many PSF sets are generated in a matlab programming winodow
% For each set, there are k = 4 phase aberration levels.
% Total # of psf = Nmatlab*Npsfset*4
% 
% for example: Generate 50 sets (total 50*4*10 = 2000 PSFs) per pool.
% using_pool = 10;
% total_PSF = 2000;
% k = 4;
% parfor ii = 1:using_pool
%   GeneratePSF_SameChannelData(ii,total_PSF/using_pool/k);
% end


addpath('./Field2');
savepath = './simulation_data_SharePSF'; % where to save PSFs
if ~exist(savepath, 'dir')
    mkdir(savepath) % create dir
end
% --------- fixed parameters ---------
% total # of psf = Npsf*Npt*4
rngseed     = (Nmatlab-1)*Npsfset + (7414:7414+Npsfset-1);  % random number generator seed
Npx         = 257;               % number of pixels of generated RF/baseband data along x direction
Npz         = 257;               % number of pixels of generated RF/baseband data along z direction
fs          = 100e6;             % sampling rate 100 MHz
soundv      = 1540;              % sound velocity [m/s]
height      = 5e-3;              % = 5 mm
kerf        = 0;
Nelements   = 128;               % number of array element
focus       = [0 0 1e3]/1000;    % initial electronic focus at 1000 mm
f_num       = 2;                 % f#
beamspacing = 4;                 % how many pixel in one beam (beam width)
gain        = 60;                % image gain
DR          = 60;                % dynamic range
psfsegx     = 32/2;              % physical FOVx, x-direction segmentation size, 16 lambda width from central point for both left and right side, unit in lambda
psfsegz     = 16/2;              % physical FOVz, z-direction segmentation size, 8 lambda height from central point for both top and bottom, unit in lambda
maxdelay    = [0, 1, 1.5, 2]/4;  % max phase error level, unit in pi
% enlarge speckle patch size, [scale for k=1, scale for k=2, ...]
% e.g. 2x speckle patch size for all k
% specklescale_x = [2,2,2,2];      % x direction scale factor 
% specklescale_z = [2,2,2,2];      % z direction scale factor  
specklescale_x = [1,1,1,1];      % x direction scale factor 
specklescale_z = [1,1,1,1];      % z direction scale factor 
for ii = 1:Npsfset
close all
rng(rngseed(ii))
ind = ii + (Nmatlab-1)*Npsfset; % according to the i-th matlab window
fprintf('Now generating... %d psf\n', ind)
% --------- parameters ---------
f0     = (3 + 4.5*rand(1))*1e6;        % center freq. 3~7.5 MHz
bw     = 0.5 + 0.3*rand(1);            % fractional bandwidth 0.5 ~ 0.8
lambda = soundv/f0;                    % wave length 205.3 ~ 513.3 um
pitch  = lambda/2;                     % pitch size 
% Note: Jason set 0.3 mm, but it leads to artifacts on sidelobe in some cases because pitch < lambda/2 may not suffic sampling theory)
dz0    = soundv/fs/2;                  % original depth (time) interval, derived from 2dz/soundv = 1/fs
FOVx   = ceil(psfsegx*2*lambda/pitch); % field of view, the x-direction size of beamformed RF data.
% lambda = soundv/f0; dt = lambda/soundv = 1/f0 (one-way wavelength);
% convert length to # of pixelsã€€=> dt = 1/f0 = ?*1/fs => ? = 1/f0*fs = fs/f0
lambda_in_sample = fs/f0;   % lambda length represented in sample. [13.333 33.3333]
% ------ generate full dataset using Field II ------
field_init(0)
set_field('fs',fs);
set_field('c', soundv);
% 1 tx and all 128 rx in one time, total 128 elements so there are 128*128 acquisitions
% xdc_linear_array(# of element, width, height, kerf, # of sub x, # of sub y, focus)
Th  = xdc_linear_array(Nelements, pitch, height, kerf, 1, 1, focus); % pt to the transmitted aperture
Th2 = xdc_linear_array(Nelements, pitch, height, kerf, 1, 1, focus); % pt to the received aperture
tc  = gauspuls('cutoff', f0, bw, -6, -80);
tp  = -tc:1/fs:tc; % pulse time axis
% system impulse response
impulse_response = gauspuls(tp, f0, bw, -6);
impulse_response = impulse_response.*hanning(length(impulse_response))';
xdc_impulse(Th, impulse_response); 
xdc_impulse(Th2, impulse_response);
% ecitation pulse
excitation                = 10*sin(2*pi*f0*(0:1/fs:2/f0)); % a sine wave
excitation(excitation>1)  = 1;   % limit value under 1
excitation(excitation<-1) = -1;  % excitation range [-1,1]
excitation = excitation.*hanning(length(excitation))'; % like a rectangular wave
xdc_excitation(Th, excitation);
% point source location
ptloc = zeros(3,3);
ptloc(1,3) = 1/1e3;                 % first point location: 1 mm
ptloc(2,3) = (10 + 30*rand(1))/1e3;  % setting point location: 10 ~ 40 mm
ptloc(3,3) = 45/1e3; % last point location: 45mm
% Only the second point will be displayed, other points are set for Field
% II determining start and end.
amp      = ones(size(ptloc, 1), 1);
amp(1)   = eps;
amp(end) = eps;
% calc_scat_all (Th1, Th2, pts' position, pts' amplitudes, dec_factor)
[v, t]   = calc_scat_all(Th, Th2, ptloc, amp, 1); 
% v's dim = (Nsample, Nelements*Nelements), where Nsample is related to the sampling rate 
xdc_free(Th);
field_end
full_dataset = reshape(v, [], Nelements, Nelements); % size = (Nsample, received by the i-th element, emitted by the i-th element)
Noffset = round((t-2*tc)*fs); % t*fs: the time for the first sample in v (fieldII), round(2*tc*fs): two-way half pulse length offset
Nsample = size(full_dataset, 1); % size(v, 1) depending on sampling rate


% ------ prepare for beamformed RF data ------ 
% For 3D  delay buffer, the definition is:
% (z-direction of shape Nsample, beamspacing*Nelements [target point in beam space], Nelements [tx or rx element])
% Coordinate setup
% x_elem: x location at each element's center, length = Nelements
% x_range/x_aline: x location at each beam's center in beam buffer (beam space), length = beamspacing*Nelements

x_elem   = (-(Nelements-1)/2:(Nelements-1)/2)*pitch; % central location of each element
x_range  = ((FOVx-1)/2 + 1/beamspacing*(beamspacing-1)/2)*pitch; % central location of the leftest and rightest beam
x_beam   = -x_range:pitch/beamspacing:x_range; % central location of each beam
% 3D element's x location, dimension = (copy the i-th element's location (Nsamples), copy the i-th element's location (FOV including beamspacing), i-th element location)
xx_elem  = repelem(reshape(x_elem, 1,1,[]), Nsample, FOVx*beamspacing, 1); % size = (Nsample, FOVx*beamspacing, Nelements)
% 3D beam's x location, dimension = (copy the i-th beam's location (Nsamples), i-th beam location, copy the i-th beam's location (Nelements))
xx_beam  = repmat(reshape(x_beam, [1,FOVx*beamspacing,1]), [Nsample, 1, Nelements]); % size = (Nsample, FOVx*beamspacing, Nelements)
z        = dz0*(Noffset + (0:Nsample-1)'); % depth axis, size = (Nsample,1)
% calculate delay buffer, distance btw the i-th element to all beam
% xx_beam - xx_elem: x-direction distance btw the i-th element and the n-th beam, size = (distance at different depth, distance btw n-th aline to the i-th element, the i-th element location)
% abs(X+1j*Z): a way (Jason use :) ) to calculate the Euclidean distance d(x,z) ~~
distance  = abs(xx_beam - xx_elem + 1j*repmat(z,[1,FOVx*beamspacing, Nelements])); % size = (Nsample, # of aline, # of element), unit in "mm" instead of time or sample.
% slice the desired FOV for beamforming and imaging region to reduce time
% consumption during beamforming
[~, z_pt_start_ind] = min(abs(z - (ptloc(2,3) - psfsegz*lambda) )); % start index of a PSF region
[~, z_pt_end_ind] = min(abs(z - (ptloc(2,3) + psfsegz*lambda) ));   % end index of a PSF region
beamformed_region_z = z(z_pt_start_ind:z_pt_end_ind);
distance = distance(z_pt_start_ind:z_pt_end_ind, :,:);
% in order to convert the array index to "general index"
% e.g. value at (2,2,2) in a 3*3*3 matrix, its general index is 2*(3*3*3) + 1*3 + 2 = 59, i.e. the 59-th element in this array
index3D  = repelem((0:Nelements-1)*(Nsample+1), Nsample,1,Nelements) + ... % 2-nd dim index
           repelem(reshape((Nsample+1)*Nelements*(0:Nelements-1), 1,1,[]), Nsample, Nelements, 1); % 3-rd dim index
index3D = uint32(index3D); % in order to reduce memory consumption
index3D = index3D(z_pt_start_ind:z_pt_end_ind, :,:); % slice the desired FOV for beamforming and imaging

% ------ delay profile ------
% the phase aberration profile follows the near field phase screen model
% and assumes its correlation length to be 5mm. 
% Note: Code in this part is from Jason. I try to add comment but sincerely
% don't know where the correlation length is 5 mm ...
x    = randn(1, Nelements); % Nelements delay
bt   = 0.5; % the 3-dB bandwidth-symbol time product
sps  = 16;  % samples per symbol
span = 8;   % filter spans 8 symbols
% total 8*16 = 128 + 1 sample
h    = gaussdesign(bt, span, sps);
base_delay_curve = conv(x, h, 'same');
% limit delay_curve in [-0.5,0.5]
base_delay_curve = (base_delay_curve - min(base_delay_curve));  % shift to all positive values
base_delay_curve = base_delay_curve / max(base_delay_curve);    % limited in [0,1]
base_delay_curve = base_delay_curve - 0.5;                 % limited in [-0.5,0.5]
for k = 1:4
    % ------ Apply delay profile ------
    aberratedchanneldata  = zeros(Nsample+1,Nelements,Nelements);
    delay_curve = base_delay_curve * maxdelay(k);
    delay_curve_in_sample = round(delay_curve * lambda_in_sample); % delay how many samples
    for itx = 1:Nelements 
        % full_dataset(:, :, itx): one channel data, obtained by the itx-th transmitting element and all received Nelements.
        % delay_curve1(itx): delay applied to only one tx element
        % delay_curve1: delay applied to all Nelements
        aberratedchanneldata(1:end-1, :, itx) = Apply_Delay(full_dataset(:, :, itx), delay_curve_in_sample+delay_curve_in_sample(itx)); 
    end
    % ------ STA beamforming ------
    psf_rf = zeros(length(beamformed_region_z), length(x_beam));
    for Nline = 1:length(x_beam) % beamform an aline in one time
        % f # mask: abs(x_beam(Nline) - x_elem) only consider one side of aperture so it requires to 2*
        % f_num_mask_rx: where the aperture larger than f # (how many rx elements used, (aperture for different depth, which rx element used, copy all rx element's mask along tx element)
        % f_num_mask_tx: where the aperture larger than f # (how many tx elements used, (aperture for different depth, copy the i-th tx element's mask along rx element, which tx element used)
        f_num_mask_rx = double(beamformed_region_z./(2*abs(x_beam(Nline) - x_elem)) > f_num); % size = (Nsample, Nelements) = (Nsample, Nelements, 1)
        f_num_mask_tx = reshape(f_num_mask_rx, length(beamformed_region_z), 1, Nelements);      % size = (Nsample, 1, Nelements)
        Nlinedistance = distance(:,Nline,:) + squeeze(distance(:,Nline,:));         % distance btw the Nline-th beam and tx + rx element
        % delay(:,Nline,:): tx delay, (delay at different depth, copy the same delay for each tx element, delay btw the Nline-th beam and i-th element)
        % squeeze(delay(:,Nline,:)): rx delay, (delay at different depth, delay btw all beam and i-th element, copy the same delay for each tx element)
        channel_ind = ceil(Nlinedistance/soundv*fs - Noffset); % convert delay in time to in sample
        channel_ind(channel_ind > Nsample) = Nsample + 1; % limit delay index
        channel_ind(channel_ind < 1) = Nsample + 1; % received signal before t=0
        channel_ind = uint32(channel_ind) + index3D; % convert array index to general index
        % sum the channel data from the ? tx elements and ? rx elements,where ? is related to the f # mask.
        % dimension means (Nsample, channel data from rx element, channel data from tx element)
        psf_rf(:,Nline) = sum(f_num_mask_rx.*f_num_mask_tx.*aberratedchanneldata(channel_ind), [2,3]); 
    end
%     lpf = fir1(48, f0/(fs/2))'; % cutoff freq. at 0.8*(bw*f0) Hz
%     BBdata = conv2(RFdata.*exp(-1j*2*pi*f0*(0:size(RFdata, 1)-1)'/fs), lpf, 'same');
%     % -------- PSF Preprocessing ---------
%     envelope = abs(BBdata);
%     envelope_dB = 20*log10(envelope/max(envelope, [], 'all')+eps);
% 
%     figure;
%     image(x_aline*1e3, z*1e3, envelope_dB+gain);
%     colormap(gray(DR));colorbar;
%     xlabel('Lateral position (mm)')
%     ylabel('Depth (mm)')
%     axis image;

%     % check delay channel data
%     tmp = aberratedchanneldata(channel_ind);
%     figure
%     for ii = 1:size(tmp,2)
%         plot(z*1e3,1e-26*ii+tmp(:,ii,128)), hold on
%     end

        

        % interpolate or resize x and z axis to adapt for the desired FOV
        newz = interp1(z_pt_start_ind:z_pt_end_ind, z(z_pt_start_ind:z_pt_end_ind), linspace(z_pt_start_ind,z_pt_end_ind,Npz));
        depth = z(z_pt_start_ind);
        dx = x_beam(2) - x_beam(1);
        dz = newz(2) - newz(1);
        newfs = soundv/2/dz;
        lpf = fir1(48, f0/(newfs/2))';
        % resize RF psf to desired FOV
        psf_rf = imresize(psf_rf, [Npz,Npx], 'bicubic');
        % Note: Results from bicubic and bilinear are tinny difference.
        psf_bb = conv2(psf_rf.*exp(-1j*2*pi*f0*(0:size(psf_rf,1)-1)'./newfs), lpf, 'same');
%         psf_bb = conv2(psf_rf.*exp(-1j*2*pi*f0*(2*newz'/soundv)), lpf, 'same');
        envelope = abs(psf_bb);
        envelope_dB = 20*log10(envelope/max(envelope, [], 'all')+eps);
        fig = figure('visible','off');
        subplot(121)
        image(x_beam*1e3, newz*1e3, envelope_dB+gain);
        colormap(gray(DR));colorbar;
        xlabel('Lateral position (mm)')
        ylabel('Depth (mm)')
        axis image;

        % -----  Generate speckle ----- 
        % enlarge the patch size to preserve the edge information in advanced
        % (Npx - 1)*2 + 1: enlarge 2 times patch size to preserve information
        % and ensure number of pixels is odd which is helpful to be sliced.
        % *specklescale_x(k): enlarge speckle patch size in order to check the model
        % performance.
        Nsx = (Npx - 1)*specklescale_x(k)*2 + 1;
        Nsz = (Npz - 1)*specklescale_z(k)*2 + 1;
        % generate scatterer distribution
        den         = 0.05 + 0.45*rand(1);                    % scatterer's density, [0.05,0.5]
        Nscat       = round(den*Nsz*Nsx);                   % number of scatterers with in a patch
        scat_space  = zeros(Nsz,Nsx);                       % distribution space size = (Npz,Npx)
        scat_indice = randi(numel(scat_space),[1,Nscat]);   % scatterer's location at which index
        scat_space(scat_indice) = randn(Nscat,1);           % scatterer's amplitude (random normal)
        scat_space = reshape(scat_space, [Nsz, Nsx]);
        % generate RF speckle
        speckle_rf = conv2(scat_space, psf_rf, 'same'); % psf is a filter
        % segment the patch with size (Npz,Npx)
        % (Nsz+1)/2: the center index along this direction
        % (Npx - 1)*specklescale(k)/2: the top N or bottom N indices
        speckle_rf = speckle_rf((Nsz+1)/2 - (Npz-1)*specklescale_z(k)/2:(Nsz+1)/2 + (Npz-1)*specklescale_z(k)/2, (Nsx+1)/2 - (Npx-1)*specklescale_x(k)/2:(Nsx+1)/2 + (Npx-1)*specklescale_x(k)/2);
        speckle_rf = imresize(speckle_rf, [Npz,Npx], 'bicubic');
%         speckle_bb = conv2(speckle_rf.*exp(-1j*2*pi*f0*(2*newz'/soundv)), lpf, 'same');
        % since the speckle patch may be enlarged, the sampling rate or spacing is
        % changed.
        newfs = soundv/2/(dz*specklescale_z(k));
        % change the cutoff freq cuz the sampling rate is changed.
        % e.g. original cutoff freq: f0/(fs/2), but newfs = fs/specklescale
        % to be "at the same cutoff freq": f0/(fs/2) -> f0/(specklescale*newfs/2)
        lpf = fir1(48, f0/(newfs*specklescale_z(k)/2))';
        speckle_bb = conv2(speckle_rf.*exp(-1j*2*pi*f0*(0:size(speckle_rf,1)-1)'./newfs), lpf, 'same');
        envelope = abs(speckle_bb);
        envelope_dB = 20*log10(envelope/max(envelope, [], 'all')+eps);
        
        subplot(122)
        image(specklescale_x(k)*x_beam*1e3, specklescale_z(k)*newz*1e3, envelope_dB+gain);
        colormap(gray(DR));colorbar;
        xlabel('Lateral position (mm)')
        ylabel('Depth (mm)')
        axis image;
%         parsave(fullfile(savepath,['Data_', num2str(Nptperset*(ind-1)+(ipt-1)), '_delay_', num2str(k), '.mat']), psf_rf, psf_bb, speckle_rf, speckle_bb, dx, dz, depth, f0, k, bw, delay_curve);
        save(fullfile(savepath,['Data_', num2str(ceil(ind/length(maxdelay))), '_delay_', num2str(k), '.mat']), 'psf_rf', 'psf_bb', 'speckle_rf', 'speckle_bb', 'dx', 'dz', 'depth', 'f0', 'k', 'bw', 'delay_curve');
        saveas(fig, fullfile(savepath,['Data_', num2str(ceil(ind/length(maxdelay))), '_delay_', num2str(k), '.png']));
    
end
end
end

